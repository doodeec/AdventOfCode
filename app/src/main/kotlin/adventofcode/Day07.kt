/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package adventofcode

import kotlin.math.max
import kotlin.math.min

class Day07 {

    fun part1() {
        println("=== Part 1 ===")
        val testInput = getResourceAsStringCollection("day07_test.txt")
        val testResult = getPart1(testInput)
        println("test result - $testResult")
        if (testResult != 6440) throw Exception("example not passing")

        val input = getResourceAsStringCollection("day07_input.txt")
        val result = getPart1(input)
        println("result - $result")
    }

    fun part2() {
        println("=== Part 2 ===")
        val testInput = getResourceAsStringCollection("day07_test.txt")
        val testResult = getPart2(testInput)
        println("test result - $testResult")
        if (testResult != 5905) throw Exception("example not passing")

        val input = getResourceAsStringCollection("day07_input.txt")
        val result = getPart2(input)
        println("result - $result")
    }

    private fun getPart1(input: List<String>): Int {
        val hands = input.map { line ->
            val parts = line.split("\\s+".toRegex())
            val hand = parts[0]
            val bid = parts[1].toInt()

            Hand(
                input = hand,
                bid = bid,
                cardsValue = hand.map { cardsValueOrder.indexOf(it).toString().padStart(2, '0') }
                    .joinToString("").toInt(),
                type = hand.toType(),
            )
        }

        //println("\nhands ${hands.joinToString("\n")}")

        val ranked = hands.sortedWith(object : Comparator<Hand> {
            override fun compare(a: Hand, b: Hand): Int {
                val aType = a.type.strength
                val bType = b.type.strength
                if (aType == bType) return b.cardsValue.compareTo(a.cardsValue)
                return aType.compareTo(bType)
            }
        })

        //println("\nranked ${ranked.joinToString("\n")}")

        var result = 0
        ranked.forEachIndexed { index, hand ->
            result += hand.bid * (index + 1)
        }
        return result
    }

    private fun getPart2(input: List<String>): Int {
        val hands = input.map { line ->
            val parts = line.split("\\s+".toRegex())
            val hand = parts[0]
            val bid = parts[1].toInt()

            Hand(
                input = hand,
                bid = bid,
                cardsValue = hand.map { cardsValueOrder2.indexOf(it).toString().padStart(2, '0') }
                    .joinToString("").toInt(),
                type = hand.toType2(),
            )
        }

        //println("\nhands ${hands.joinToString("\n")}")

        val ranked = hands.sortedWith(object : Comparator<Hand> {
            override fun compare(a: Hand, b: Hand): Int {
                val aType = a.type.strength
                val bType = b.type.strength
                if (aType == bType) return b.cardsValue.compareTo(a.cardsValue)
                return aType.compareTo(bType)
            }
        })

        //println("\nranked ${ranked.joinToString("\n")}")

        var result = 0
        ranked.forEachIndexed { index, hand ->
            result += hand.bid * (index + 1)
        }
        return result
    }

    private val cardsValueOrder = listOf('A', 'K', 'Q', 'J', 'T', '9', '8', '7', '6', '5', '4', '3', '2')
    private val cardsValueOrder2 = listOf('A', 'K', 'Q', 'T', '9', '8', '7', '6', '5', '4', '3', '2', 'J')

    private fun String.toType(): Type {
        val x: List<Int> = cardsValueOrder.map { c -> this.count { it == c } }

        return when {
            x.contains(5) -> Type.FiveOfAKind
            x.contains(4) -> Type.FourOfAKind
            x.contains(3) && x.contains(2) -> Type.FullHouse
            x.contains(3) -> Type.ThreeOfAKind
            x.count { it == 2 } == 2 -> Type.TwoPair
            x.contains(2) -> Type.OnePair
            else -> Type.HighCard
        }
    }

    private fun String.toType2(): Type {
        var x = cardsValueOrder2.map { c -> if (c == 'J') 0 else this.count { it == c } }.sortedDescending()
        var jokers = this.count { it == 'J' }
        
        while (jokers > 0) {
            x = x.map {
                if (it < 5) {
                    val y = min(it + jokers, 5)
                    jokers -= (y - it)
                    y
                } else it
            }
        }

        return when {
            x.contains(5) -> Type.FiveOfAKind
            x.contains(4) -> Type.FourOfAKind
            x.contains(3) && x.contains(2) -> Type.FullHouse
            x.contains(3) -> Type.ThreeOfAKind
            x.count { it == 2 } == 2 -> Type.TwoPair
            x.contains(2) -> Type.OnePair
            else -> Type.HighCard
        }
    }

    data class Hand(
        val input: String,
        val bid: Int,
        val cardsValue: Int,
        val type: Type,
    )

    enum class Type(val strength: Int) {
        HighCard(0),
        OnePair(1),
        TwoPair(2),
        ThreeOfAKind(3),
        FullHouse(4),
        FourOfAKind(5),
        FiveOfAKind(6);
    }
}

fun main() {
    Day07().apply {
        part1()
        part2()
    }
}
