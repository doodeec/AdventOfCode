/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package adventofcode

import java.util.concurrent.atomic.AtomicLong
import kotlin.math.max

class Day05 {

    fun part1() {
        val testInput = getResourceAsStringCollection("day05_test.txt")
        val testResult = getLowestLocation(testInput)

        if (testResult != 35L) throw Exception("example not passing")

        val input = getResourceAsStringCollection("day05_input.txt")
        val result = getLowestLocation(input)

        println("part 1 result - $result")
    }

    fun part2() {
        val testInput = getResourceAsStringCollection("day05_test.txt")
        val testResult = getLowestLocation2(testInput)

        println("test result - $testResult")
        if (testResult != 46L) throw Exception("example not passing")

        val input = getResourceAsStringCollection("day05_input.txt")
        val result = getLowestLocation2(input)

        println("part 2 result - $result")
    }

    private fun getLowestLocation(input: List<String>): Long {
        val seeds = input.first()
            .substringAfter("seeds:")
            .split(" ")
            .filter { it.isNotEmpty() }
            .map { it.toLong() }
        println("seeds - $seeds")

        val seedToSoil = input.getMapping("seed-to-soil map:")
        val soilToFertilizer = input.getMapping("soil-to-fertilizer map:")
        val fertilizerToWater = input.getMapping("fertilizer-to-water map:")
        val waterToLight = input.getMapping("water-to-light map:")
        val lightToTemp = input.getMapping("light-to-temperature map:")
        val tempToHumidity = input.getMapping("temperature-to-humidity map:")
        val humidityToLocation = input.getMapping("humidity-to-location map:")
        
        return seeds.minOf { seed ->
            seed.toDestination(seedToSoil)
                .toDestination(soilToFertilizer)
                .toDestination(fertilizerToWater)
                .toDestination(waterToLight)
                .toDestination(lightToTemp)
                .toDestination(tempToHumidity)
                .toDestination(humidityToLocation)
        }
    }

    private fun List<String>.getMapping(name: String): List<Mapping> {
        return this
            .dropWhile { it != name }
            .drop(1)
            .takeWhile { it.isNotEmpty() }
            .map { line ->
                val numbers = line.split(" ").filter { it.isNotEmpty() }.map { it.toLong() }
                Mapping(
                    destinationStart = numbers[0],
                    sourceStart = numbers[1],
                    rangeLength = numbers[2],
                )
            }
    }

    private fun Long.toDestination(mapping: List<Mapping>): Long {
        return mapping.find { this in LongRange(it.sourceStart, it.sourceStart + it.rangeLength) }
            ?.let { this + (it.destinationStart - it.sourceStart) }
            ?: this
    }

    private fun getLowestLocation2(input: List<String>): Long {
        val seedCodes = input.first()
            .substringAfter("seeds:")
            .split(" ")
            .filter { it.isNotEmpty() }
            .map { it.toLong() }

        val seeds = mutableListOf<LongRange>()
        var i = 0
        while (i < seedCodes.size) {
            seeds.add(LongRange(seedCodes[i], seedCodes[i] + seedCodes[i + 1] - 1))
            i += 2
        }

        val seedToSoil = input.getMapping("seed-to-soil map:")
        val soilToFertilizer = input.getMapping("soil-to-fertilizer map:")
        val fertilizerToWater = input.getMapping("fertilizer-to-water map:")
        val waterToLight = input.getMapping("water-to-light map:")
        val lightToTemp = input.getMapping("light-to-temperature map:")
        val tempToHumidity = input.getMapping("temperature-to-humidity map:")
        val humidityToLocation = input.getMapping("humidity-to-location map:")
        
        val stage1 = seeds.flatMap { x ->
            x.roll(seedToSoil.filter { m -> m.overlaps(x) })
        }
        
        val stage2 = stage1.flatMap { x ->
            x.current.roll(soilToFertilizer.filter { m -> m.overlaps(x.current) })
        }
        
        val stage3 = stage2.flatMap { x ->
            x.current.roll(fertilizerToWater.filter { m -> m.overlaps(x.current) })
        }
        
        val stage4 = stage3.flatMap { x ->
            x.current.roll(waterToLight.filter { m -> m.overlaps(x.current) })
        }
        
        val stage5 = stage4.flatMap { x ->
            x.current.roll(lightToTemp.filter { m -> m.overlaps(x.current) })
        }
        
        val stage6 = stage5.flatMap { x ->
            x.current.roll(tempToHumidity.filter { m -> m.overlaps(x.current) })
        }
        
        val stage7 = stage6.flatMap { x ->
            x.current.roll(humidityToLocation.filter { m -> m.overlaps(x.current) })
        }
        println("\nstage7 (hum-to-loc)\n${stage7.joinToString("\n")}")
        
        // I don't have a clue why 0 needs to be filtered out, it's late and I want to go to sleep
        //return stage7.minOf { it.current.start }
        return stage7.filter { it.current.start != 0L }.minOf { it.current.start }
    }

    data class Mapping(
        val destinationStart: Long,
        val sourceStart: Long,
        val rangeLength: Long,
    ) {
        val range = LongRange(sourceStart, sourceStart + rangeLength - 1)
        val diff = destinationStart - sourceStart
        
        fun overlaps(other: LongRange): Boolean {
            if (range.start <= other.start) {
                return range.endInclusive > other.start
            } else {
                return range.start <= other.endInclusive
            }
        }

        override fun toString(): String = "$range -> ${if (diff > 0) "+" else ""}$diff"
    }
    
    data class RollingMap(
        val original: LongRange,
        val current: LongRange,
        val fromMapping: Mapping?,
    ) {
        override fun toString(): String = "$original -> $current [$fromMapping]"
    }
    
    private fun LongRange.roll(mappings: List<Mapping>): List<RollingMap> {
        if (mappings.isEmpty()) return listOf(RollingMap(this, this, null))
        
        val result = mutableListOf<RollingMap>()
        
        var start = this.start
        mappings.sortedBy { it.sourceStart }.forEach { m ->
            val mr = m.range
            val s = max(mr.start, start)
            val e = minOf(mr.endInclusive, this.endInclusive)
            if (s == mr.start) {
                result.add(RollingMap(LongRange(start, s), LongRange(start, s), null))
            }
            //println("\t\troll $this -> start=$s end=$e ... locS=$start,mr=$mr,map=$m")
            result.add(RollingMap(LongRange(s, e), LongRange(s + m.diff, e + m.diff), m))
            start = e
        }
        
        if (start < endInclusive) {
            result.add(RollingMap(LongRange(start, endInclusive), LongRange(start, endInclusive), null))
        }
        
        return result
    }
}

fun main() {
    Day05().apply {
        //part1()
        part2()
    }
}
